%&cheri_compartments_preamble
\endofdump

\begin{document}
\maketitle

\section{Introduction}

CHERI capabilities implicitly portion a program into \emph{compartments}, but
there are two fundamentally different flavours of creating CHERI compartments
-- both of which can be used within a single process -- and several
sub-flavours of each. Our aim in this draft paper is to outline the different
forms of compartments that CHERI enables.


\section{Background}

We assume high-level familiarity with capabilities (an approachable historical overview
is~\cite{levy84capability}, which may usefully be augmented by more recent work
such as \cite{miller06robust}),
CHERI generally (see e.g.~this introduction~\cite{watson20cheriintroduction}),
the CHERI ABI~\cite{brooks19cheriabi},
and CHERI C (the dialect of C that CHERI defines)~\cite{watson20chericprogramming}.

Because CHERI has been developed over a number of years, and is explained over
a variety of documentation and papers, some concepts have more than one name.
We have found that some of those names make it difficult to talk, and sometimes
reason about, capability usage.
Unfortunately, we can think of no better solution to this than to propose our
own terminology.

We use the term \textit{CHERI} to refer to the `abstract capability machine'
that software can observe: that is, the combination of a capability hardware
instruction set, an ABI, and a user-facing library that exposes capability-related functions.
We refer to specific hardware implementations by their name
(e.g.~Arm's `Morello', or `CHERI RISC-V').

CHERI capabilities are immutable and thus a new \emph{child}
capability must be derived from one or more \emph{parent} capabilities.
We refer to a capability as \emph{authentic} (what CHERI calls
`tagged' or `valid') if it has been derived from its parents according
to CHERI's rules, or \emph{inauthentic} (what CHERI calls `untagged' or `invalid')
otherwise. A capability consists of an \emph{address} in memory
and a set of \emph{permissions}. Amongst the permissions are
\emph{bounds} -- the region of memory an authentic capability is allowed to
read/write from/to. A capability's bounds are from a \emph{low} (inclusive) to
a \emph{high} (exclusive) address and we refer to `a bound of $x$ bytes' to mean
a capability where $\textit{high}-\textit{low}=x$.
If a capability's address is contained within its bounds we refer to the capability as
a whole as \emph{in-bounds} or \emph{out-of-bounds} otherwise
(see~\cite{woodruff19chericoncentrate} for an explanation of why an authentic
capability might have an out-of-bounds address). Other permissions include
boolean flags such as whether a capability can read/write to memory addresses
within its bounds.

As well as capabilities (which on Morello and CHERI RISC-V, for example, are
implemented as double-width addresses), CHERI also allows `traditional' single-width addresses
to be used. Conventionally, a program which uses both traditional addresses and
capabilities is said to be operating in \emph{hybrid} mode while a program
which uses only capabilities is in \emph{pure capability} mode.


\section{Pure capability compartmentalisation}

\begin{figure}
\begin{center}
\begin{tikzpicture}[
  align=center,
  node distance=2.8cm and 4cm,
  every by arrow/.style={*->},
  every edge/.style={draw,->,>=stealth',
  auto,
  semithick
}]
\node[state, shape=rectangle] (B1) {};
\node[state, shape=rectangle, right of=B1] (B2) {};
\node[state, shape=rectangle, right of=B2] (B3) {};
\node[state, shape=rectangle, right of=B3] (B4) {};
\node[state, shape=rectangle, right of=B4] (B5) {};
\path[->] (B1) edge[above] node{C1} (B2);
\path[->] (B2) edge[bend left, above] node{C2} (B3);
\path[->] (B3) edge[bend left, below] node{C3} (B2);
\path[->] (B3) edge[above] node{C4} (B4);
\path[->] (B4) edge[above] node{C5} (B5);
\end{tikzpicture}

\vspace{10pt}

\begin{tabular}{ll}
\toprule
Root set & Reachable set \\
\midrule
\{C1\} & \{C1, C2, C3, C4, C5\} \\
\{C2\} & \{C2, C3, C4, C5\} \\
\{C3\} & \{C2, C3, C4, C5\} \\
\{C4\} & \{C4, C5\} \\
\{C5\} & \{C5\} \\
\bottomrule
\end{tabular}

\caption{Pure capabilities form a graph: the root set of capabilities a program
has access to determine the full set of reachable capabilities the
program can reach. The diagram above represents a simplification of the
running state of a pure capability program: each square constitutes a
block of memory containing zero or more capabilities; an outgoing edge
from a block signifies that it stores a capability pointing to another
block; each capability has the \texttt{LOAD\_CAP} permission set so
that it can load capabilities from the block of memory points to; and
each capability has its bounds set to cover
exactly one other block of memory. The table then shows the graph of
reachable capabilities if, at a specific point in time, the root set of
capabilities (i.e.~those capabilities the program can immediately
access because they are stored in e.g.~registers) contains exactly one
element.}
\end{center}
\label{fig:reachability}
\end{figure}


Pure capability CHERI programs implicitly or explicitly use capabilities to
define compartments. Figure~\ref{fig:reachability} shows an example of one
particular flavour of compartment, but there are others. In this Section we
show examples of different, overlapping, flavours of pure capability
compartments.


\subsection{Memory compartmentalisation}

\laurie{LOAD\_CAP, I think, implicitly defines this. entirely dynamic.}


\subsection{Link-time compartmentalisation}

\laurie{What Hesham calls `ELF/linkage-based or library-based compartmentalization'}


\section{Hybrid compartmentalisation}

\subsection{Morello unattended compartmentalisation}

Supposing compartmentalisation is performed between two unprivileged
compartments via a privileged entity, it makes sense for an attacker to focus
their efforts attacking that privileged compartment switcher, to perhaps gain
access to the whole system. One possible approach to tighten security is to
minimize the functionality of such a switcher: by identifying what it means to
perform a transition from one compartment to another, we can prepare a switching
mechanism that only performs the required instructions, with minimal interaction
with the rest of the environment, and is thus less likely to be misused.

To exemplify, we model a simple system with two compartments (and will be
abstracting away some of the finer details, such as memory management). Suppose
we have two compartments, named \(f\) and \(g\). To further simplify this model,
we shall assume each compartment is comprised of a single function of interest,
and a compartment transition involves executing that particular function, then
returning. We shall further assume that each compartment has its own memory
region, which serves as both stack and heap (again, specific details of memory
allocation will be omitted), disjoint with memory regions of the other
compartment.

(TODO: explain DDC/PCC)
With the above model, a compartment transition would involve:
\begin{itemize}
\item identify the target compartment to be transitioned to, effectively
executing the corresponding compartment function;
\item install a capability in the \texttt{DDC} which covers the memory region
corresponding to the target compartment;
\item install a capability pointing to the target function in the \texttt{PCC},
and start execution;
\item upon returning from executing the target function, reinstall the
\texttt{DDC} corresponding to the source compartment memory region.
\end{itemize}
The above process involves some level of trust between compartments, as they
require access to capabilities defining memory accessible by the other
compartment, as well as executable code within that compartment. Having access
to these capabilities means lack of CHERI security guarantees over these ares in
memory. Thus, we can strengthen our model by suggesting \emph{mutual distrust}
between compartments themselves. This involves adding a level of indirection in
the above process. We define a concrete ``transition state'', comprising of both
executable code involving setting the state for compartment transitions (i.e.,
installing capabilities with correct bounds in \texttt{PCC} and \texttt{DDC}
registers), as well as a memory region containing compartment information (the
aforementioned capabilities defining compartments' allocated memory regions, and
visible executable code).

Let's update the process above, by adding a setup phase to create required
capabilities ahead of time, and to introduce indirection during the compartment
transition function. We require the following capabilities be constructed ahead
of time, in a privileged environment:
\begin{itemize}
\item for each compartment, a capability defining the accessible memory region
of that compartment;
\item for each compartment, a capability defining the executable part of that
compartment which should be callable by other compartments;
\item a capability defining a separate memory region to hold the above
capabilities;
\item a capability covering the code which will perform the transition;
\item a capability that points to the memory address where the previous two
capabilities are stored, consecutively, and in that order.
\end{itemize}
The first two types of capabilities will be stored under the memory region
allocated for compartment transitioning. The following two capabilities will
similarly be stored in the same memory region, but available to the compartments
indirectly by the final capability (which shall be discussed in more detail
shortly). Copies of the final capability are provided to each compartment, to be
stored within their respective memory regions, and to facilitate compartment
transitioning.

With the above setup in place, we can observe that
\begin{enumerate}
\item during compartment transitioning, we have access to data defining each
compartment's visible executable code and accessible memory,
\item and compartment transitioning is done within its own, separate scope, and
does not give full permissions over the whole system.
\end{enumerate}
However, it is important to note that this transition state does not have
privileged execution. It is indeed the case that were a malign actor gain
control of the memory region where comaprtment information is stored, it would
be able to gain control of all compartments using that specific transition code.
However, it would not gain control of any other part of the whole system.

The actual process by which the switching code is invoked is via the Morello
\texttt{ldpblr} instruction\cite{...}, which stands for ``Load Pair Branch with
Link''. Given a register containing a capability, the instructions dereferences
the memory address indicated by the value of the capability, reads two
consecutive capabilities stored at that memory address, installs the first
capability in the \texttt{DDC}, and performs a \texttt{blr} with the second
(meaning installing the second in the \texttt{PCC}, and updating the
\texttt{CLR} to the following instruction, to facilitate returning from the
called function). This level of indirection allows a compartment to essentially
change the state defined by the environment, by setting both \texttt{DDC} and
\texttt{PCC} at once, without actually having access to them both as they would
potentially reside outside memory defined as accessibly by the compartment's own
\texttt{DDC} capability. Further, we can \emph{seal} the capability providing
the indirect memory address of the switcher's capabilities with a
Morello-specific object type of \texttt{lpb}, indicating the capability should
only be used as part of \texttt{lpb}-like instructions (which include
\texttt{ldpblr}). This, however, requires the indirect memory capability be
installed in register \texttt{c29}, as the unsealing operation is only performed
if that is the source register provided to \texttt{ldpblr}.






\bibliographystyle{plain}
\bibliography{bib}

\end{document}
