%&cheri_compartments_preamble
\endofdump

\begin{document}
\maketitle

\section{Introduction}

CHERI capabilities implicitly portion a program into \emph{compartments}, but
there are two fundamentally different flavours of creating CHERI compartments
-- both of which can be used within a single process -- and several
sub-flavours of each. Our aim in this draft paper is to outline the different
forms of compartments that CHERI enables.


\section{Background}

We assume high-level familiarity with capabilities (an approachable historical overview
is~\cite{levy84capability}, which may usefully be augmented by more recent work
such as \cite{miller06robust}),
CHERI generally (see e.g.~this introduction~\cite{watson20cheriintroduction}),
the CHERI ABI~\cite{brooks19cheriabi},
and CHERI C (the dialect of C that CHERI defines)~\cite{watson20chericprogramming}.

Because CHERI has been developed over a number of years, and is explained over
a variety of documentation and papers, some concepts have more than one name.
We have found that some of those names make it difficult to talk, and sometimes
reason about, capability usage.
Unfortunately, we can think of no better solution to this than to propose our
own terminology.

We use the term \textit{CHERI} to refer to the `abstract capability machine'
that software can observe: that is, the combination of a capability hardware
instruction set, an ABI, and a user-facing library that exposes capability-related functions.
We refer to specific hardware implementations by their name
(e.g.~Arm's `Morello', or `CHERI RISC-V').

CHERI capabilities are immutable and thus a new \emph{child}
capability must be derived from one or more \emph{parent} capabilities.
We refer to a capability as \emph{authentic} (what CHERI calls
`tagged' or `valid') if it has been derived from its parents according
to CHERI's rules, or \emph{inauthentic} (what CHERI calls `untagged' or `invalid')
otherwise. A capability consists of an \emph{address} in memory
and a set of \emph{permissions}. Amongst the permissions are
\emph{bounds} -- the region of memory an authentic capability is allowed to
read/write from/to. A capability's bounds are from a \emph{low} (inclusive) to
a \emph{high} (exclusive) address and we refer to `a bound of $x$ bytes' to mean
a capability where $\textit{high}-\textit{low}=x$.
If a capability's address is contained within its bounds we refer to the capability as
a whole as \emph{in-bounds} or \emph{out-of-bounds} otherwise
(see~\cite{woodruff19chericoncentrate} for an explanation of why an authentic
capability might have an out-of-bounds address). Other permissions include
boolean flags such as whether a capability can read/write to memory addresses
within its bounds.

As well as capabilities (which on Morello and CHERI RISC-V, for example, are
implemented as double-width addresses), CHERI also allows `traditional' single-width addresses
to be used. Conventionally, a program which uses both traditional addresses and
capabilities is said to be operating in \emph{hybrid} mode while a program
which uses only capabilities is in \emph{pure capability} mode.


\section{Pure capability compartmentalisation}

\begin{figure}
\begin{center}
\begin{tikzpicture}[
  align=center,
  node distance=2.8cm and 4cm,
  every by arrow/.style={*->},
  every edge/.style={draw,->,>=stealth',
  auto,
  semithick
}]
\node[state, shape=rectangle] (B1) {};
\node[state, shape=rectangle, right of=B1] (B2) {};
\node[state, shape=rectangle, right of=B2] (B3) {};
\node[state, shape=rectangle, right of=B3] (B4) {};
\node[state, shape=rectangle, right of=B4] (B5) {};
\path[->] (B1) edge[above] node{C1} (B2);
\path[->] (B2) edge[bend left, above] node{C2} (B3);
\path[->] (B3) edge[bend left, below] node{C3} (B2);
\path[->] (B3) edge[above] node{C4} (B4);
\path[->] (B4) edge[above] node{C5} (B5);
\end{tikzpicture}

\vspace{10pt}

\begin{tabular}{ll}
\toprule
Root set & Reachable set \\
\midrule
\{C1\} & \{C1, C2, C3, C4, C5\} \\
\{C2\} & \{C2, C3, C4, C5\} \\
\{C3\} & \{C2, C3, C4, C5\} \\
\{C4\} & \{C4, C5\} \\
\{C5\} & \{C5\} \\
\bottomrule
\end{tabular}

\caption{Pure capabilities form a graph: the root set of capabilities a program
has access to determine the full set of reachable capabilities the
program can reach. The diagram above represents a simplification of the
running state of a pure capability program: each square constitutes a
block of memory containing zero or more capabilities; an outgoing edge
from a block signifies that it stores a capability pointing to another
block; each capability has the \texttt{LOAD\_CAP} permission set so
that it can load capabilities from the block of memory points to; and
each capability has its bounds set to cover
exactly one other block of memory. The table then shows the graph of
reachable capabilities if, at a specific point in time, the root set of
capabilities (i.e.~those capabilities the program can immediately
access because they are stored in e.g.~registers) contains exactly one
element.}
\end{center}
\label{fig:reachability}
\end{figure}


Pure capability CHERI programs implicitly or explicitly use capabilities to
define compartments. Figure~\ref{fig:reachability} shows an example of one
particular flavour of compartment, but there are others. In this Section we
show examples of different, overlapping, flavours of pure capability
compartments.


\subsection{Memory compartmentalisation}

\laurie{LOAD\_CAP, I think, implicitly defines this. entirely dynamic.}


\subsection{Link-time compartmentalisation}

\laurie{What Hesham calls `ELF/linkage-based or library-based compartmentalization'}


\section{Hybrid compartmentalisation}

\subsection{Morello unattended compartmentalisation}

Supposing compartmentalisation is performed between to unprivileged compartments
via a privileged entity, it makes sense for an attacker to focus their efforts
attacking that privileged compartment switcher. One possible approach to tighten
security is to minimize the functionality of such a switcher: by identifying
what it means to perform a transition from one compartment to another, we can
prepare a switching mechanism that only performs the required instructions, and
is thus less likely to be misused.

To exemplify, we model a simple system with two compartments (and will be
abstracting away some of the finer details, such as memory management). Suppose
we have two compartments, named \(f\) and \(g\). To further simplify this model,
we shall assume each compartment is comprised of a single function of interest,
and a compartment transition involves executing that particular function, then
returning. We shall further assume that each compartment has its own memory
region, which serves as both stack and heap (again, specific details of memory
allocation will be omitted), disjoint with memory regions of the other
compartment.

With the above model, a compartment transition would involve:
\begin{itemize}
\item identify the function within the target compartment to be called;
\item install a capability in the \texttt{DDC} which covers the memory region
corresponding to the target compartment;
\item install a capability pointing to the target function in the \texttt{PCC},
and start execution;
\item upon returning from executing the target function, reinstall the
\texttt{DDC} corresponding to the source compartment memory region.
\end{itemize}
The above process involves some level of trust between compartments, as they
require access to capabilities defining memory accessible by the other
compartment, as well as executable code within that compartment. Having access
to these capabilities means lack of CHERI security guarantees over these ares in
memory. Thus, we can strengthen our model by suggesting \emph{mutual distrust}
between compartments themselves. This involves adding a level of indirection in
the above process. We define a concrete ``transition state'', comprising of both
executable code involving setting the state for compartment transitions (i.e.,
installing capabilities with correct bounds in \texttt{PCC} and \texttt{DDC}
registers), as well as a memory region containing compartment information (the
aforementioned capabilities defining compartments' allocated memory regions, and
visible executable code).

Let's update the process above, by adding a setup phase to create required
capabilities ahead of time, and to introduce indirection during the compartment
transition function. We require the following capabilities be constructed ahead
of time, in a privileged environment:
\begin{itemize}
\item for each compartment, a capability defining the accessible memory region
of that compartment;
\item for each compartment, a capability defining the executable part of that
compartment which should be callable by other compartments;
\item a capability defining a separate memory region to hold the above
capabilities;
\item a capability covering the code which will perform the transition;
\item a capability that points to the memory address where the previous two
capabilities are stored, consecutively, and in that order.
\end{itemize}
The first two types of capabilities will be stored under the memory region
allocated for compartment transitioning. The following two capabilities will
similarly be stored in the same memory region, but available to the compartments
indirectly by the final capability (which shall be discussed in more detail
shortly). Copies of the final capability are provided to each compartment, to be
stored within their respective memory regions, and to facilitate compartment
transitioning.

With the above setup in place, we can observe that
\begin{enumerate}[label={(\alph*)}]
\item during compartment transitioning, we have access to data defining each
compartment's visible executable code and accessible memory,
\item and compartment transitioning is done within its own, separate scope, and
does not give full permissions over the whole system.
\end{enumerate}






\bibliographystyle{plain}
\bibliography{bib}

\end{document}
